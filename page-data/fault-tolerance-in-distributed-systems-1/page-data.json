{"componentChunkName":"component---src-templates-blog-post-js","path":"/fault-tolerance-in-distributed-systems-1/","result":{"data":{"site":{"siteMetadata":{"title":"Shantanu's Weblog"}},"markdownRemark":{"id":"48ba1dfa-3bf5-5914-b7e8-25bc2ad7b8da","excerpt":"“Fault tolerance” or being able to handle any type of fault in itself is a motivation for distributed systems. This is one of the most widely studied topics in…","html":"<p>“Fault tolerance” or being able to handle any type of fault in itself is a motivation for distributed systems. This is one of the most widely studied topics in the area of Distributed Systems. It has remained one of the hot areas for some obvious reasons — If you are talking of a distributed environment of thousands of machines, it is evident that almost always, some will fail. Due to this very obvious fact, failures have become the norm rather than an exception.</p>\n<blockquote>\n<p>A distributed system is one in which the failure of a computer you didn’t\neven know existed can render your own computer unusable.</p>\n</blockquote>\n<p>A poorly designed Distributed System is counter-intuitive and worse than a non- distributed system. Leslie Lamport, known for his seminal work in this area wrote once <a href=\"http://research.microsoft.com/en-us/um/people/lamport/pubs/distributed-system.txt\">in an e-mail</a>-</p>\n<div class=\"gatsby-highlight\" data-language=\"nolinenumbers:leslie-lamport-letter\"><pre class=\"language-nolinenumbers:leslie-lamport-letter\"><code class=\"language-nolinenumbers:leslie-lamport-letter\">There has been considerable debate over the years about what\nconstitutes a distributed system.  It would appear that the following\ndefinition has been adopted at SRC:\n\nA distributed system is one in which the failure of a computer you didn&#39;t\neven know existed can render your own computer unusable.\n\nThe current electrical problem in the machine room is not the culprit--it just highlights\na situation that has been getting progressively worse.  It seems that each new version of\nthe nub makes my FF more dependent upon programs that run elsewhere.\n\nHaving to wait a few seconds for a program to be swapped in is a lot\nless annoying than having to wait an hour or two for someone to reboot\nthe servers.  I therefore propose a development project to make our\nsystem more robust.  I am not proposing any particular approach\n(enabling stand-alone operation is just one possibility).\n\nI will begin the effort by volunteering to gather some data on the\nproblem.  If you know of any instance of user&#39;s FF becoming inoperative\nthrough no fault of its own, please send me a message indicating the\nuser, the time, and the cause (if known).\n</code></pre></div>\n<hr>\n<h4>Failure Models:</h4>\n<p>Any behavior can be classified in a failure model if it does not comply with the designed protocol or contract.</p>\n<p>Lets look at some of the failure models considered in dealing with fault tolerance-</p>\n<p>Failure models can be classified into two broad categories-</p>\n<ol>\n<li>Node failures- Failures caused at individual node participating in a Distributed System.</li>\n<li>Communication Failures- Failures caused due to unreliable communication channels connecting the nodes.</li>\n</ol>\n<p>Let’s classify these even further</p>\n<h5>1. Node Failures</h5>\n<h6>a. Crash Failure (Fail-stop)</h6>\n<p>This is self explanatory and is the model that deals with crash of a node in the system.</p>\n<h6>b. Omission Failure (Fail-silent)</h6>\n<p>Imagine a node running normally but just misses to send or receive messages; say due to some reasons such as full buffer, slow processing etc. This type of failure is classified into the omission failures model. These failures are challenging to address. Crash failures can be viewed as a special case of Omission failure. Systems that tolerate omission failures will be able to tolerate crash failures. The reverse is not true. An omission failure could be either due to send omission or receive omission. They could also happen due to infinite loops, improper memory management etc.</p>\n<h6>c. Timing Failure</h6>\n<p>Let’s say the server’s response lies outside the specified time interval. The server replies too late due to performance issues or the server is provided with data ‘too soon’ that it does not have enough buffer to hold the data.</p>\n<h6>d. Response Failure</h6>\n<p>This is one of the serious types of failures where the server’s response is simply incorrect. Either it can simply return incorrect data which can be called as “value failure” or can go into a state transition failure in case of an unexpected request; just like calling a bad function into the default case of a switch case block.</p>\n<h6>e. Byzantine Failure/ Arbitrary Failure</h6>\n<p>This model classifies failures (aberration) caused due to a malicious node that is controlled by some attacker and is the most serious of all. Interestingly, even though big companies such as Google, Facebook, Amazon, etc. are extremely wary about security and expect no Byzantine failures due to malicious behavior per se, they are still concerned about Byzantine failures due to a very different reason. Remember- we are now speaking of data at Google scale. Even smallest order of data corruption at a site can propagate to all the sites leading to a major overhead! Measures to eschew Byzantine failures thus needed for data at large scale. Byzantine failures were first analyzed by Pease et al. (1980) and Lamport et al. (1982).</p>\n<h6>f. Selfish Behavior</h6>\n<p>In this case, the node is just uncooperative. Consider a P2P distributed scenario of torrent. You are one of the participant but selfish enough to download at full bandwidth but refuse to seed even a bit!</p>\n<p>Failure models a,b,c,d, and f are as described in <a href=\"http://www.ict.kth.se/courses/2G1126/vt03/papers/cristian93understanding.pdf\">Cristian (1991)</a> and <a href=\"http://disi.unitn.it/~montreso/ds/syllabus/papers/FaultTolerantBroadcast.pdf\">Hadzilacos and Toueg (1993).</a></p>\n<h5>2.Communication failures</h5>\n<p>Communication channels involved can be prone to failures and drop messages transmitted via the network.</p>\n<p>Many other failure models can be defined specific to any context. But these definitions are rarely used and hence not documented in the general sense.</p>\n<p>Also look at Part 2: Timing models used in distributed context.</p>","frontmatter":{"title":"Fault Tolerance in Distributed Systems: Introduction","date":"October 28, 2014","description":null}},"previous":{"fields":{"slug":"/ten-things-i-learnt-from-my-first-manager/"},"frontmatter":{"title":"10 Things I Learnt From My First Manager"}},"next":{"fields":{"slug":"/fault-tolerance-in-distributed-systems-2/"},"frontmatter":{"title":"Fault Tolerance in Distributed Systems: Timing Models"}}},"pageContext":{"id":"48ba1dfa-3bf5-5914-b7e8-25bc2ad7b8da","previousPostId":"a389957c-c920-5636-9f9d-8f513626ef89","nextPostId":"421e29d0-752e-5784-a5a6-d4637905f809"}},"staticQueryHashes":["2841359383"]}